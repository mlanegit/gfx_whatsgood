import type { NodePath } from "@babel/traverse";
import type * as t from "@babel/types";
import { StaticArrayProcessor } from "./processors/static-array-processor.js";

export class JSXProcessor {
  private staticArrayProcessor: StaticArrayProcessor;

  constructor(
    private types: typeof t,
    private filename: string
  ) {
    this.staticArrayProcessor = new StaticArrayProcessor(types);
  }

  processJSXElement(path: NodePath<t.JSXOpeningElement>): void {
    if (this.hasAttribute(path, "data-source-location")) return;

    this.addSourceLocationAttribute(path);
    this.addDynamicContentAttribute(path);
    this.addContentEditableAttribute(path);
    this.staticArrayProcessor.process(path);
  }

  private addSourceLocationAttribute(
    path: NodePath<t.JSXOpeningElement>
  ): void {
    const { line, column } = path.node.loc?.start || { line: 1, column: 0 };
    const value = `${this.filename}:${line}:${column}`;

    path.node.attributes.push(
      this.types.jsxAttribute(
        this.types.jsxIdentifier("data-source-location"),
        this.types.stringLiteral(value)
      )
    );
  }

  private addDynamicContentAttribute(
    path: NodePath<t.JSXOpeningElement>
  ): void {
    const parentElement = path.parentPath;
    if (!parentElement?.isJSXElement()) return;

    const isDynamic = this.checkIfElementHasDynamicContent(
      parentElement.node as t.JSXElement
    );

    path.node.attributes.push(
      this.types.jsxAttribute(
        this.types.jsxIdentifier("data-dynamic-content"),
        this.types.stringLiteral(isDynamic ? "true" : "false")
      )
    );
  }

  private addContentEditableAttribute(
    path: NodePath<t.JSXOpeningElement>
  ): void {
    path.node.attributes.push(
      this.types.jsxAttribute(
        this.types.jsxIdentifier("content-editable"),
        this.types.stringLiteral("true")
      )
    );
  }

  private hasAttribute(
    path: NodePath<t.JSXOpeningElement>,
    name: string
  ): boolean {
    return path.node.attributes.some(
      (attr: t.JSXAttribute | t.JSXSpreadAttribute) =>
        this.types.isJSXAttribute(attr) &&
        this.types.isJSXIdentifier(attr.name) &&
        attr.name.name === name
    );
  }

  private checkIfElementHasDynamicContent(jsxElement: t.JSXElement): boolean {
    let hasDynamicContent = false;

    const checkNode = (node: t.Node): boolean => {
      if (this.types.isJSXExpressionContainer(node)) {
        const expression = (node as t.JSXExpressionContainer).expression;
        if (this.types.isJSXEmptyExpression(expression)) return false;
        if (!this.types.isLiteral(expression)) return true;
      }

      if (
        this.types.isTemplateLiteral(node) &&
        (node as t.TemplateLiteral).expressions.length > 0
      ) {
        return true;
      }
      if (this.types.isMemberExpression(node)) return true;
      if (this.types.isCallExpression(node)) return true;
      if (this.types.isConditionalExpression(node)) return true;

      if (this.types.isIdentifier(node)) {
        const dynamicNames = [
          "props",
          "state",
          "data",
          "item",
          "value",
          "text",
          "content",
        ];
        if (dynamicNames.some((name) => (node as t.Identifier).name.includes(name))) {
          return true;
        }
      }

      return false;
    };

    const traverseNode = (node: Record<string, unknown>): void => {
      if (hasDynamicContent) return;
      if (checkNode(node as unknown as t.Node)) {
        hasDynamicContent = true;
        return;
      }

      for (const key of Object.keys(node)) {
        if (hasDynamicContent) return;
        const value = node[key];

        if (Array.isArray(value)) {
          for (const child of value) {
            if (child && typeof child === "object" && "type" in child) {
              traverseNode(child as Record<string, unknown>);
            }
          }
        } else if (value && typeof value === "object" && "type" in value) {
          traverseNode(value as Record<string, unknown>);
        }
      }
    };

    for (const child of jsxElement.children) {
      if (hasDynamicContent) break;
      traverseNode(child as unknown as Record<string, unknown>);
    }

    return hasDynamicContent;
  }
}
