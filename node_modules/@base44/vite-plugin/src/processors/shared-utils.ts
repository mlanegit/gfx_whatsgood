import type { NodePath } from "@babel/traverse";
import type * as t from "@babel/types";
import { JSXUtils } from "../jsx-utils.js";

export class JSXAttributeUtils {
  constructor(private types: typeof t) {}

  hasAttribute(
    path: NodePath<t.JSXOpeningElement>,
    attributeName: string
  ): boolean {
    return path.node.attributes.some(
      (attr: t.JSXAttribute | t.JSXSpreadAttribute) =>
        this.types.isJSXAttribute(attr) &&
        JSXUtils.getAttributeName(attr) === attributeName
    );
  }

  addStringAttribute(
    path: NodePath<t.JSXOpeningElement>,
    attributeName: string,
    value: string
  ): void {
    if (!this.hasAttribute(path, attributeName)) {
      path.node.attributes.push(
        this.types.jsxAttribute(
          this.types.jsxIdentifier(attributeName),
          this.types.stringLiteral(value)
        )
      );
    }
  }

  addExpressionAttribute(
    path: NodePath<t.JSXOpeningElement>,
    attributeName: string,
    expression: t.Expression
  ): void {
    if (!this.hasAttribute(path, attributeName)) {
      path.node.attributes.push(
        this.types.jsxAttribute(
          this.types.jsxIdentifier(attributeName),
          this.types.jsxExpressionContainer(expression)
        )
      );
    }
  }
}

export class StaticValueUtils {
  constructor(private types: typeof t) {}

  isPrimitiveLiteral(path: NodePath<t.Node>): boolean {
    return (
      path.isStringLiteral() ||
      path.isNumericLiteral() ||
      path.isBooleanLiteral() ||
      path.isNullLiteral()
    );
  }

  isStaticValue(
    path: NodePath<t.Node>,
    visited: Set<string> = new Set()
  ): boolean {
    if (this.isPrimitiveLiteral(path)) return true;
    if (path.isIdentifier()) return this.isStaticIdentifier(path, visited);
    if (path.isObjectExpression()) return this.isStaticObject(path, visited);
    if (path.isArrayExpression())
      return this.isStaticArrayExpression(path, visited);
    return false;
  }

  isStaticIdentifier(
    path: NodePath<t.Identifier>,
    visited: Set<string> = new Set()
  ): boolean {
    const binding = path.scope.getBinding(path.node.name);
    if (!binding) return false;

    if (binding.kind === "module") return true;

    if (binding.kind === "const" && binding.path.isVariableDeclarator()) {
      const name = path.node.name;
      if (visited.has(name)) return false;
      visited.add(name);

      const init = binding.path.get("init");
      if (init.hasNode()) {
        return this.isStaticValue(init as NodePath<t.Node>, visited);
      }
    }

    return false;
  }

  isStaticObject(
    path: NodePath<t.ObjectExpression>,
    visited: Set<string> = new Set()
  ): boolean {
    return path.get("properties").every((prop: NodePath) => {
      if (!prop.isObjectProperty()) return false;
      return this.isStaticValue(prop.get("value") as NodePath<t.Node>, visited);
    });
  }

  isStaticArrayExpression(
    arrayExpression: NodePath<t.ArrayExpression>,
    visited: Set<string> = new Set()
  ): boolean {
    return arrayExpression.get("elements").every((element) => {
      if (!element.node || element.isSpreadElement()) return true;
      return this.isStaticValue(element as unknown as NodePath<t.Node>, visited);
    });
  }
}
