/** Check if an element has instrumentation attributes */
export function isInstrumentedElement(element) {
    const htmlEl = element;
    return !!(htmlEl.dataset?.sourceLocation || htmlEl.dataset?.visualSelectorId);
}
/** Get the selector ID from an element's data attributes (prefers source-location) */
export function getElementSelectorId(element) {
    const htmlEl = element;
    return (htmlEl.dataset?.sourceLocation ||
        htmlEl.dataset?.visualSelectorId ||
        null);
}
export const ALLOWED_ATTRIBUTES = ["src"];
/** Find elements by ID - first try data-source-location, fallback to data-visual-selector-id */
export function findElementsById(id) {
    if (!id)
        return [];
    const sourceElements = Array.from(document.querySelectorAll(`[data-source-location="${id}"]`));
    if (sourceElements.length > 0) {
        return sourceElements;
    }
    return Array.from(document.querySelectorAll(`[data-visual-selector-id="${id}"]`));
}
/**
 * Update element classes by visual selector ID.
 * Uses setAttribute instead of className to support both HTML and SVG elements.
 */
export function updateElementClasses(elements, classes) {
    elements.forEach((element) => {
        element.setAttribute("class", classes);
    });
}
/** Set a single attribute on all provided elements. */
export function updateElementAttribute(elements, attribute, value) {
    if (!ALLOWED_ATTRIBUTES.includes(attribute)) {
        return;
    }
    elements.forEach((element) => {
        element.setAttribute(attribute, value);
    });
}
/** Collect attribute values from an element for a given allowlist. */
export function collectAllowedAttributes(element, allowedAttributes) {
    const attributes = {};
    for (const attr of allowedAttributes) {
        const val = element.getAttribute(attr);
        if (val !== null) {
            attributes[attr] = val;
        }
    }
    return attributes;
}
//# sourceMappingURL=utils.js.map